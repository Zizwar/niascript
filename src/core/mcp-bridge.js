export class MCPBridge {
  constructor(niaInstance) {
    this.nia = niaInstance;
    this.mcpTools = new Map();
    this.mcpClients = new Map();
    this.logger = niaInstance.logger;
    this.isInitialized = false;
  }

  async initialize() {
    try {
      this.logger.info('Initializing MCP Bridge...');
      
      // Initialize MCP client connections
      await this.initializeMCPClients();
      
      // Discover available MCP tools
      await this.discoverMCPTools();
      
      this.isInitialized = true;
      this.logger.info('MCP Bridge initialized successfully');
      
    } catch (error) {
      this.logger.error('Failed to initialize MCP Bridge:', error);
      throw error;
    }
  }

  async initializeMCPClients() {
    // ูู ุงูุชุทุจูู ุงูุญููููุ ูุฐุง ุณูุชุตู ุจู MCP servers
    // ููุง ุณูุญุงูู ุจุนุถ MCP clients
    
    const mockClients = [
      {
        name: 'filesystem',
        description: 'File system operations',
        url: 'mcp://filesystem',
        tools: ['read_file', 'write_file', 'list_directory', 'delete_file']
      },
      {
        name: 'web_search',
        description: 'Web search capabilities',
        url: 'mcp://web-search',
        tools: ['search_web', 'get_page_content', 'extract_links']
      },
      {
        name: 'weather',
        description: 'Weather information',
        url: 'mcp://weather',
        tools: ['get_current_weather', 'get_forecast', 'get_weather_alerts']
      }
    ];

    for (const clientConfig of mockClients) {
      await this.connectMCPClient(clientConfig);
    }
  }

  async connectMCPClient(clientConfig) {
    try {
      // ูุญุงูุงุฉ ุงูุงุชุตุงู ุจู MCP client
      const client = {
        name: clientConfig.name,
        description: clientConfig.description,
        url: clientConfig.url,
        tools: clientConfig.tools,
        connected: true,
        lastPing: new Date()
      };

      this.mcpClients.set(clientConfig.name, client);
      this.logger.info(`Connected to MCP client: ${clientConfig.name}`);

      return client;
    } catch (error) {
      this.logger.error(`Failed to connect to MCP client ${clientConfig.name}:`, error);
      throw error;
    }
  }

  async discoverMCPTools() {
    for (const [clientName, client] of this.mcpClients) {
      for (const toolName of client.tools) {
        await this.registerMCPToolAsPlugin(clientName, toolName, client);
      }
    }
  }

  async registerMCPToolAsPlugin(clientName, toolName, client) {
    try {
      const toolConfig = await this.getMCPToolConfig(clientName, toolName);
      
      const plugin = {
        name: `mcp_${clientName}_${toolName}`,
        version: "1.0.0",
        description: `MCP tool: ${toolConfig.description || toolName}`,
        author: "MCP Bridge",
        
        triggers: [
          new RegExp(toolName.replace(/_/g, '[\\s_]'), 'i'),
          new RegExp(toolConfig.keywords?.join('|') || toolName, 'i')
        ],
        
        recipes: {
          [toolName]: {
            confidence: 0.85,
            steps: [
              {
                action: "call_mcp_tool",
                client: clientName,
                tool: toolName,
                params: "${extracted_params}",
                assign_to: "mcp_result"
              },
              {
                action: "format_mcp_response",
                client: clientName,
                tool: toolName,
                result: "${mcp_result}",
                assign_to: "formatted_result"
              },
              {
                action: "format_response",
                template: "${formatted_result}",
                return: true
              }
            ]
          }
        },
        
        customActions: {
          call_mcp_tool: async (params) => {
            return await this.executeMCPTool(params.client, params.tool, params.params);
          },
          
          format_mcp_response: async (params) => {
            return await this.formatMCPResponse(params.client, params.tool, params.result);
          }
        }
      };
      
      await this.nia.pluginManager.install(plugin);
      this.mcpTools.set(`${clientName}.${toolName}`, toolConfig);
      
      this.logger.info(`Registered MCP tool as plugin: ${plugin.name}`);
      
    } catch (error) {
      this.logger.error(`Failed to register MCP tool ${clientName}.${toolName}:`, error);
    }
  }

  async getMCPToolConfig(clientName, toolName) {
    // ูุญุงูุงุฉ ุงูุญุตูู ุนูู ุชูููู MCP tool
    const toolConfigs = {
      'filesystem.read_file': {
        description: 'Read contents of a file',
        keywords: ['read', 'file', 'content', 'ุงูุฑุฃ', 'ููู', 'ูุญุชูู'],
        parameters: {
          path: { type: 'string', required: true, description: 'File path to read' }
        }
      },
      'filesystem.write_file': {
        description: 'Write content to a file',
        keywords: ['write', 'save', 'file', 'ุงูุชุจ', 'ุงุญูุธ', 'ููู'],
        parameters: {
          path: { type: 'string', required: true, description: 'File path to write' },
          content: { type: 'string', required: true, description: 'Content to write' }
        }
      },
      'filesystem.list_directory': {
        description: 'List contents of a directory',
        keywords: ['list', 'directory', 'folder', 'ุงุนุฑุถ', 'ูุฌูุฏ', 'ูุงุฆูุฉ'],
        parameters: {
          path: { type: 'string', required: true, description: 'Directory path' }
        }
      },
      'web_search.search_web': {
        description: 'Search the web for information',
        keywords: ['search', 'web', 'google', 'ุจุญุซ', 'ููุจ', 'ุงุจุญุซ'],
        parameters: {
          query: { type: 'string', required: true, description: 'Search query' },
          limit: { type: 'number', required: false, description: 'Number of results' }
        }
      },
      'weather.get_current_weather': {
        description: 'Get current weather for a location',
        keywords: ['weather', 'current', 'temperature', 'ุทูุณ', 'ุฏุฑุฌุฉ', 'ุญุฑุงุฑุฉ'],
        parameters: {
          location: { type: 'string', required: true, description: 'Location name or coordinates' }
        }
      }
    };

    const toolKey = `${clientName}.${toolName}`;
    return toolConfigs[toolKey] || {
      description: `MCP tool: ${toolName}`,
      keywords: [toolName],
      parameters: {}
    };
  }

  async executeMCPTool(clientName, toolName, params) {
    try {
      const client = this.mcpClients.get(clientName);
      if (!client || !client.connected) {
        throw new Error(`MCP client ${clientName} not available`);
      }

      this.logger.info(`Executing MCP tool: ${clientName}.${toolName}`);
      
      // ูุญุงูุงุฉ ุชูููุฐ MCP tool
      const mockResults = await this.getMockMCPResult(clientName, toolName, params);
      
      this.logger.info(`MCP tool executed successfully: ${clientName}.${toolName}`);
      return mockResults;
      
    } catch (error) {
      this.logger.error(`Failed to execute MCP tool ${clientName}.${toolName}:`, error);
      throw error;
    }
  }

  async getMockMCPResult(clientName, toolName, params) {
    // ูุญุงูุงุฉ ูุชุงุฆุฌ MCP tools
    const mockResults = {
      'filesystem.read_file': {
        success: true,
        content: `Mock file content for: ${params.path}`,
        size: 1024,
        lastModified: new Date().toISOString()
      },
      'filesystem.write_file': {
        success: true,
        message: `File written successfully: ${params.path}`,
        bytesWritten: params.content?.length || 0
      },
      'filesystem.list_directory': {
        success: true,
        files: [
          { name: 'file1.txt', type: 'file', size: 1024 },
          { name: 'file2.js', type: 'file', size: 2048 },
          { name: 'subfolder', type: 'directory', size: 0 }
        ],
        total: 3
      },
      'web_search.search_web': {
        success: true,
        results: [
          {
            title: `Search result for: ${params.query}`,
            url: 'https://example.com/result1',
            snippet: 'This is a mock search result...',
            rank: 1
          },
          {
            title: `Another result for: ${params.query}`,
            url: 'https://example.com/result2',
            snippet: 'This is another mock search result...',
            rank: 2
          }
        ],
        totalResults: 2
      },
      'weather.get_current_weather': {
        success: true,
        location: params.location,
        temperature: 25,
        humidity: 60,
        windSpeed: 10,
        condition: 'Partly Cloudy',
        lastUpdated: new Date().toISOString()
      }
    };

    const toolKey = `${clientName}.${toolName}`;
    return mockResults[toolKey] || {
      success: true,
      message: `Mock result for ${toolKey}`,
      params: params
    };
  }

  async formatMCPResponse(clientName, toolName, result) {
    // ุชูุณูู ูุชุงุฆุฌ MCP tools ุญุณุจ ููุน ุงูุฃุฏุงุฉ
    const formatters = {
      'filesystem.read_file': (result) => {
        if (result.success) {
          return `๐ ูุญุชูู ุงูููู:\n${result.content}\n\nุงูุญุฌู: ${result.size} ุจุงูุช\nุขุฎุฑ ุชุนุฏูู: ${result.lastModified}`;
        } else {
          return `โ ูุดู ูู ูุฑุงุกุฉ ุงูููู: ${result.error}`;
        }
      },
      
      'filesystem.write_file': (result) => {
        if (result.success) {
          return `โ ${result.message}\nุชู ูุชุงุจุฉ ${result.bytesWritten} ุจุงูุช`;
        } else {
          return `โ ูุดู ูู ูุชุงุจุฉ ุงูููู: ${result.error}`;
        }
      },
      
      'filesystem.list_directory': (result) => {
        if (result.success) {
          const fileList = result.files.map(file => 
            `${file.type === 'directory' ? '๐' : '๐'} ${file.name} (${file.size} ุจุงูุช)`
          ).join('\n');
          return `๐ ูุญุชููุงุช ุงููุฌูุฏ (${result.total} ุนูุตุฑ):\n${fileList}`;
        } else {
          return `โ ูุดู ูู ุนุฑุถ ุงููุฌูุฏ: ${result.error}`;
        }
      },
      
      'web_search.search_web': (result) => {
        if (result.success) {
          const resultList = result.results.map(item => 
            `${item.rank}. ${item.title}\n   ${item.url}\n   ${item.snippet}`
          ).join('\n\n');
          return `๐ ูุชุงุฆุฌ ุงูุจุญุซ (${result.totalResults} ูุชูุฌุฉ):\n\n${resultList}`;
        } else {
          return `โ ูุดู ูู ุงูุจุญุซ: ${result.error}`;
        }
      },
      
      'weather.get_current_weather': (result) => {
        if (result.success) {
          return `๐ค๏ธ ุงูุทูุณ ูู ${result.location}:\n` +
                 `ุฏุฑุฌุฉ ุงูุญุฑุงุฑุฉ: ${result.temperature}ยฐC\n` +
                 `ุงูุฑุทูุจุฉ: ${result.humidity}%\n` +
                 `ุณุฑุนุฉ ุงูุฑูุงุญ: ${result.windSpeed} ูู/ุณุงุนุฉ\n` +
                 `ุงูุญุงูุฉ: ${result.condition}\n` +
                 `ุขุฎุฑ ุชุญุฏูุซ: ${result.lastUpdated}`;
        } else {
          return `โ ูุดู ูู ุงูุญุตูู ุนูู ุงูุทูุณ: ${result.error}`;
        }
      }
    };

    const toolKey = `${clientName}.${toolName}`;
    const formatter = formatters[toolKey];
    
    if (formatter) {
      return formatter(result);
    } else {
      return `ูุชูุฌุฉ ${toolName}: ${JSON.stringify(result, null, 2)}`;
    }
  }

  async disconnectMCPClient(clientName) {
    try {
      const client = this.mcpClients.get(clientName);
      if (client) {
        // ูุญุงูุงุฉ ูุทุน ุงูุงุชุตุงู
        client.connected = false;
        
        // ุฅุฒุงูุฉ ุงูุฅุถุงูุงุช ุงููุฑุชุจุทุฉ ุจูุฐุง ุงูุนููู
        for (const [toolKey] of this.mcpTools) {
          if (toolKey.startsWith(`${clientName}.`)) {
            const pluginName = `mcp_${toolKey.replace('.', '_')}`;
            try {
              await this.nia.pluginManager.uninstall(pluginName);
            } catch (error) {
              this.logger.error(`Failed to uninstall plugin ${pluginName}:`, error);
            }
          }
        }
        
        this.mcpClients.delete(clientName);
        this.logger.info(`Disconnected MCP client: ${clientName}`);
      }
    } catch (error) {
      this.logger.error(`Failed to disconnect MCP client ${clientName}:`, error);
      throw error;
    }
  }

  async refreshMCPTools() {
    try {
      this.logger.info('Refreshing MCP tools...');
      
      // ุฅุนุงุฏุฉ ุงูุชุดุงู ุงูุฃุฏูุงุช
      await this.discoverMCPTools();
      
      this.logger.info('MCP tools refreshed successfully');
    } catch (error) {
      this.logger.error('Failed to refresh MCP tools:', error);
      throw error;
    }
  }

  getMCPClients() {
    return Array.from(this.mcpClients.values());
  }

  getMCPTools() {
    return Array.from(this.mcpTools.keys());
  }

  async healthCheck() {
    const results = {};
    
    for (const [clientName, client] of this.mcpClients) {
      try {
        // ูุญุงูุงุฉ ูุญุต ุงูุตุญุฉ
        const isHealthy = client.connected && (Date.now() - client.lastPing.getTime()) < 60000;
        
        results[clientName] = {
          status: isHealthy ? 'healthy' : 'unhealthy',
          lastPing: client.lastPing,
          toolsCount: client.tools.length
        };
      } catch (error) {
        results[clientName] = {
          status: 'error',
          error: error.message
        };
      }
    }
    
    return results;
  }

  isReady() {
    return this.isInitialized && this.mcpClients.size > 0;
  }
}